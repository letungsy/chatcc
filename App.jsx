import React, { useState, useEffect, useRef } from 'react'; import { Camera, Mic, Plus, Send, Menu, X } from 'lucide-react'; // Translations const translations = { vi: { appTitle: 'ChatAI', newChat: 'Cuá»™c trÃ² chuyá»‡n má»›i', history: 'Lá»‹ch sá»­', newChatTitle: 'Cuá»™c trÃ² chuyá»‡n má»›i', hintMessage: 'Nháº­p tin nháº¯n...', imageSelected: 'ÄÃ£ chá»n áº£nh', fileSelected: 'ÄÃ£ chá»n file', micPermission: 'Cáº§n quyá»n ghi Ã¢m Ä‘á»ƒ sá»­ dá»¥ng tÃ­nh nÄƒng nÃ y', speechSuccess: 'âœ“ Nháº­n diá»‡n thÃ nh cÃ´ng', errorLoading: 'Lá»—i táº£i' }, en: { appTitle: 'ChatAI', newChat: 'New Chat', history: 'History', newChatTitle: 'New Chat', hintMessage: 'Type a message...', imageSelected: 'Image selected', fileSelected: 'File selected', micPermission: 'Microphone permission needed', speechSuccess: 'âœ“ Speech recognized', errorLoading: 'Error loading' }, ja: { appTitle: 'ChatAI', newChat: 'æ–°ã—ã„ãƒãƒ£ãƒƒãƒˆ', history: 'å±¥æ­´', newChatTitle: 'æ–°ã—ã„ãƒãƒ£ãƒƒãƒˆ', hintMessage: 'ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’å…¥åŠ›...', imageSelected: 'ç”»åƒãŒé¸æŠã•ã‚Œã¾ã—ãŸ', fileSelected: 'ãƒ•ã‚¡ã‚¤ãƒ«ãŒé¸æŠã•ã‚Œã¾ã—ãŸ', micPermission: 'ãƒã‚¤ã‚¯ã®è¨±å¯ãŒå¿…è¦ã§ã™', speechSuccess: 'âœ“ éŸ³å£°èªè­˜æˆåŠŸ', errorLoading: 'èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼' }, zh: { appTitle: 'ChatAI', newChat: 'æ–°å¯¹è¯', history: 'å†å²è®°å½•', newChatTitle: 'æ–°å¯¹è¯', hintMessage: 'è¾“å…¥æ¶ˆæ¯...', imageSelected: 'å·²é€‰æ‹©å›¾ç‰‡', fileSelected: 'å·²é€‰æ‹©æ–‡ä»¶', micPermission: 'éœ€è¦éº¦å…‹é£æƒé™', speechSuccess: 'âœ“ è¯­éŸ³è¯†åˆ«æˆåŠŸ', errorLoading: 'åŠ è½½é”™è¯¯' } }; const models = [ { id: 'groq', label: 'âš¡ Groq' }, { id: 'cohere', label: 'ğŸ§  Cohere' }, { id: 'gemini-flash', label: 'ğŸ’ Gemini Flash' }, { id: 'gemini-pro', label: 'ğŸ‘‘ Gemini Pro' } ]; const languages = [ { code: 'vi', label: 'ğŸ‡»ğŸ‡³ VN' }, { code: 'en', label: 'ğŸ‡¬ğŸ‡§ EN' }, { code: 'ja', label: 'ğŸ‡¯ğŸ‡µ JA' }, { code: 'zh', label: 'ğŸ‡¨ğŸ‡³ ZH' } ]; export default function ChatAIApp() { const [currentLanguage, setCurrentLanguage] = useState('vi'); const [selectedModel, setSelectedModel] = useState('groq'); const [sessions, setSessions] = useState([]); const [currentSessionId, setCurrentSessionId] = useState(''); const [message, setMessage] = useState(''); const [drawerOpen, setDrawerOpen] = useState(false); const [selectedImage, setSelectedImage] = useState(null); const [selectedFile, setSelectedFile] = useState(null); const [isRecording, setIsRecording] = useState(false); const [isSending, setIsSending] = useState(false); const scrollRef = useRef(null); const imageInputRef = useRef(null); const fileInputRef = useRef(null); const t = translations[currentLanguage]; // Load sessions from storage useEffect(() => { loadSessions(); }, []); // Auto-scroll to bottom useEffect(() => { if (scrollRef.current) { scrollRef.current.scrollTop = scrollRef.current.scrollHeight; } }, [sessions, currentSessionId]); const loadSessions = async () => { try { const stored = localStorage.getItem('chatSessions'); if (stored) { const parsed = JSON.parse(stored); setSessions(parsed); if (parsed.length > 0) { setCurrentSessionId(parsed[0].id); } else { createNewChat(); } } else { createNewChat(); } } catch (error) { console.error('Load error:', error); createNewChat(); } }; const saveSessions = (newSessions) => { try { localStorage.setItem('chatSessions', JSON.stringify(newSessions)); } catch (error) { console.error('Save error:', error); } }; const createNewChat = () => { const newSession = { id: session_${Date.now()}, title: t.newChatTitle, messages: [] }; const newSessions = [newSession, ...sessions]; setSessions(newSessions); setCurrentSessionId(newSession.id); saveSessions(newSessions); setDrawerOpen(false); }; const deleteChat = (sessionId) => { const filtered = sessions.filter(s => s.id !== sessionId); setSessions(filtered); saveSessions(filtered); if (currentSessionId === sessionId) { if (filtered.length > 0) { setCurrentSessionId(filtered[0].id); } else { createNewChat(); } } }; const switchChat = (sessionId) => { setCurrentSessionId(sessionId); setDrawerOpen(false); }; const getCurrentSession = () => { return sessions.find(s => s.id === currentSessionId); }; const handleImageSelect = (e) => { const file = e.target.files[0]; if (file) { const reader = new FileReader(); reader.onload = (event) => { setSelectedImage({ data: event.target.result, name: file.name }); }; reader.readAsDataURL(file); } }; const handleFileSelect = (e) => { const file = e.target.files[0]; if (file) { const reader = new FileReader(); reader.onload = (event) => { setSelectedFile({ data: event.target.result, name: file.name, type: file.type }); }; reader.readAsDataURL(file); } }; const startVoiceInput = async () => { if (!('webkitSpeechRecognition' in window)) { alert('Speech recognition not supported in this browser'); return; } const recognition = new webkitSpeechRecognition(); recognition.continuous = false; recognition.interimResults = false; const langMap = { vi: 'vi-VN', en: 'en-US', ja: 'ja-JP', zh: 'zh-CN' }; recognition.lang = langMap[currentLanguage] || 'vi-VN'; recognition.onstart = () => { setIsRecording(true); }; recognition.onresult = (event) => { const transcript = event.results[0][0].transcript; setMessage(transcript); setIsRecording(false); }; recognition.onerror = (event) => { console.error('Speech recognition error:', event.error); setIsRecording(false); }; recognition.onend = () => { setIsRecording(false); }; recognition.start(); }; const sendMessage = async () => { if (!message.trim() && !selectedImage && !selectedFile) return; if (isSending) return; const session = getCurrentSession(); if (!session) return; const userMessage = { text: message, isUser: true, image: selectedImage ? selectedImage.data : null, file: selectedFile ? { name: selectedFile.name, type: selectedFile.type } : null }; // Update session const updatedMessages = [...session.messages, userMessage]; const updatedSession = { ...session, messages: updatedMessages, title: session.title === t.newChatTitle ? message.substring(0, 30) : session.title }; const updatedSessions = sessions.map(s => s.id === currentSessionId ? updatedSession : s ); setSessions(updatedSessions); saveSessions(updatedSessions); // Clear input setMessage(''); const imageToSend = selectedImage; const fileToSend = selectedFile; setSelectedImage(null); setSelectedFile(null); // Send to API setIsSending(true); try { const response = await sendToAPI(message, selectedModel, imageToSend, fileToSend, currentLanguage); const aiMessage = { text: response, isUser: false }; const finalMessages = [...updatedMessages, aiMessage]; const finalSession = { ...updatedSession, messages: finalMessages }; const finalSessions = sessions.map(s => s.id === currentSessionId ? finalSession : s ); setSessions(finalSessions); saveSessions(finalSessions); } catch (error) { console.error('Send error:', error); const errorMessage = { text: Error: ${error.message}, isUser: false }; const errorMessages = [...updatedMessages, errorMessage]; const errorSession = { ...updatedSession, messages: errorMessages }; const errorSessions = sessions.map(s => s.id === currentSessionId ? errorSession : s ); setSessions(errorSessions); saveSessions(errorSessions); } finally { setIsSending(false); } }; const sendToAPI = async (text, model, image, file, language) => { const formData = new FormData(); formData.append('message', text); formData.append('model', model); formData.append('language', language); if (image) { const blob = await fetch(image.data).then(r => r.blob()); formData.append('image', blob, image.name); } if (file) { const blob = await fetch(file.data).then(r => r.blob()); formData.append('file', blob, file.name); } const response = await fetch('http://www.smilebody.sakura.ne.jp/app/chat/api.php', { method: 'POST', body: formData }); const data = await response.json(); return data.response || data.error || 'Unknown error'; }; const getFileIcon = (fileName) => { if (fileName.endsWith('.pdf')) return 'ğŸ“„'; if (fileName.endsWith('.docx') || fileName.endsWith('.doc')) return 'ğŸ“'; if (fileName.endsWith('.xlsx') || fileName.endsWith('.xls')) return 'ğŸ“Š'; return 'ğŸ“'; }; const currentSession = getCurrentSession(); return ( <div className="flex flex-col h-screen bg-[#343541]"> {/* Header */} <div className="flex items-center justify-between bg-[#202123] px-3 py-2 h-14"> <button onClick={() => setDrawerOpen(!drawerOpen)} className="w-9 h-9 bg-[#565869] text-white rounded flex items-center justify-center" > <Menu size={20} /> </button> <div className="flex items-center gap-2 flex-1 ml-3"> <span className="text-white text-lg font-bold">ğŸ’¬ {t.appTitle}</span> <select value={selectedModel} onChange={(e) => setSelectedModel(e.target.value)} className="bg-[#40414f] text-white px-2 py-1 rounded text-sm border-none outline-none" > {models.map(m => ( <option key={m.id} value={m.id}>{m.label}</option> ))} </select> <select value={currentLanguage} onChange={(e) => setCurrentLanguage(e.target.value)} className="bg-[#40414f] text-white px-2 py-1 rounded text-sm border-none outline-none" > {languages.map(l => ( <option key={l.code} value={l.code}>{l.label}</option> ))} </select> </div> </div> {/* Messages */} <div ref={scrollRef} className="flex-1 overflow-y-auto p-3"> {currentSession?.messages.map((msg, idx) => ( <div key={idx} className={mb-2 p-3 rounded ${ msg.isUser ? 'bg-[#5436DA]' : 'bg-[#30A06D]' }} > {msg.image && ( <img src={msg.image} alt="Uploaded" className="w-full max-h-60 object-cover rounded mb-2" /> )} {msg.file && ( <div className="bg-black bg-opacity-25 text-white text-xs px-2 py-1 rounded mb-2 inline-block"> {getFileIcon(msg.file.name)} {msg.file.name} </div> )} {msg.text && ( <div className="text-white text-sm">{msg.text}</div> )} </div> ))} {isSending && ( <div className="text-white text-sm opacity-50">Sending...</div> )} </div> {/* Input Area */} <div className="bg-[#202123] p-2"> {/* File Preview */} {selectedFile && ( <div className="bg-[#40414f] p-2 rounded mb-2 flex items-center justify-between"> <span className="text-white text-xs"> {getFileIcon(selectedFile.name)} {selectedFile.name} </span> <button onClick={() => setSelectedFile(null)} className="w-7 h-7 bg-red-500 text-white rounded flex items-center justify-center" > <X size={14} /> </button> </div> )} {/* Image Preview */} {selectedImage && ( <div className="mb-2 relative inline-block"> <img src={selectedImage.data} alt="Preview" className="w-24 h-24 object-cover rounded" /> <button onClick={() => setSelectedImage(null)} className="absolute -top-2 -right-2 w-7 h-7 bg-red-500 text-white rounded-full flex items-center justify-center" > <X size={14} /> </button> </div> )} {/* Input Row */} <div className="flex items-center gap-2"> <input ref={imageInputRef} type="file" accept="image/*" onChange={handleImageSelect} className="hidden" /> <button onClick={() => imageInputRef.current?.click()} className="w-10 h-10 bg-[#565869] text-white rounded flex items-center justify-center" > <Camera size={18} /> </button> <input ref={fileInputRef} type="file" accept=".pdf,.doc,.docx,.xls,.xlsx" onChange={handleFileSelect} className="hidden" /> <button onClick={() => fileInputRef.current?.click()} className="w-10 h-10 bg-[#565869] text-white rounded flex items-center justify-center" > <Plus size={20} /> </button> <input type="text" value={message} onChange={(e) => setMessage(e.target.value)} onKeyPress={(e) => e.key === 'Enter' && sendMessage()} placeholder={t.hintMessage} className="flex-1 h-10 px-3 bg-[#40414f] text-white rounded border-none outline-none" /> <button onClick={startVoiceInput} className={w-10 h-10 rounded flex items-center justify-center ${ isRecording ? 'bg-red-500' : 'bg-[#565869]' } text-white} > <Mic size={18} /> </button> <button onClick={sendMessage} disabled={isSending} className="w-12 h-10 bg-[#19c37d] text-white rounded flex items-center justify-center disabled:opacity-50" > <Send size={18} /> </button> </div> </div> {/* Drawer */} {drawerOpen && ( <> <div onClick={() => setDrawerOpen(false)} className="fixed inset-0 bg-black bg-opacity-50 z-40" /> <div className="fixed top-0 left-0 w-64 h-full bg-white z-50 shadow-lg"> <div className="flex items-center justify-between p-4 border-b"> <span className="font-bold">{t.history}</span> <button onClick={createNewChat} className="px-3 py-1 bg-[#19c37d] text-white text-sm rounded" > {t.newChat} </button> </div> <div className="overflow-y-auto h-full pb-20"> {sessions.map(session => ( <div key={session.id} className={flex items-center justify-between p-3 border-b ${ session.id === currentSessionId ? 'bg-gray-200' : '' }} > <button onClick={() => switchChat(session.id)} className="flex-1 text-left text-sm truncate" > {session.title} </button> <button onClick={() => deleteChat(session.id)} className="w-6 h-6 bg-red-500 text-white rounded flex items-center justify-center text-xs ml-2" > <X size={14} /> </button> </div> ))} </div> </div> </> )} </div> ); }
